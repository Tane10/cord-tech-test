import bodyParser from "body-parser";
import { request } from "express";
import rules from "./rules.json";

export default function (app) {
  app.set("port", process.env.PORT || 3000);
  app.use(bodyParser.json());
  app.use(bodyParser.urlencoded({ extended: true }));
}

// building SchemaValidation class
/**
 * @param {object} schema JSON schema containing rules
 */
let SchemaValidation = function (schema, request) {
  this.schema = schema;
  this.request = request;
};

SchemaValidation.prototype.validationError = function () {
  console.log("error");
};

SchemaValidation.prototype.traverseSchema = function () {
  console.log("traversing");
};

/**
 * Function that forms and returns the body, querystring and base url of the request
 * @returns body, queryString, url
 */
SchemaValidation.prototype.retrieveRequestDetails = function () {
  const body = this.request.body || {};
  const queryString = this.request.query || "";
  const url = this.request.baseUrl + this.request.path;

  return body, queryString, url;
};

/**
 * TBD: middleware that checks the request body and querystring against the
 * existing json configuration in order to ensure that:
 * all required parameters are present
 * all parameters are of the correct type
 * non-existing parameters are blocked
 *
 * @throws throw a 400 code error with a relevant error message
 *
 * @param {object} req request object generated by express
 * @param {object} res response object generated by express
 * @param {function} next middleware function
 */
export const checkAgainstRules = (req, res, next) => {
  const body = req.body;
  const queryString = req.query;
  const url = req.baseUrl + req.path;

  const validation = new SchemaValidation(rules, request);

  const rulesEntries = Object.entries(rules.paths);

  const requiredPathRule = rulesEntries.filter((entry) => {
    if (entry[0] === url) {
      return entry;
    }
  });

  // checking if rules/ route quired a param if not then pass
  if (!requiredPathRule[1][req.method].hasOwnProperty(parameters)) {
    return next();
  }

  // parameter in -> body or query

  const rulesParameters = requiredPathRule[1][req.method].parameters;

  if (rulesParameters[0].in === "body") {
    if (!body) {
      res.status(400).json({
        message: "bad request body required",
      });
    }

    const schemaType = rulesParameters[0].schema.type;
    // once we have schema type then we check using typeof
    // before type of check validate if there is a body in req
    // if the types did match how would you proceeedd
    // if this is obj check what is rwuiimport { connect } from 'react-redux'

    // map shema and filed all reuired keys and do the same with properties
    // once got map both using reduce and once keep reuired in array or object
    const requiredKeys = rulesParameters[0].schema.required;

    // handle reuired sperate in my spare time to get it done
    const properties = Object.entries(rulesParameters[0].schema.properties);

    const onlyRequiredParams = requiredKeys.reduce((prev, current) => {
      if (properties[0] === current) {
        return (prev[current] = current.type);
      }
    }, {});
  }
  //schema -> type -> object etc -> requiered true / false

  // once we have the required url then filter

  // TBD
  return next();
};
